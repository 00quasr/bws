/**
 * @file Alert.hpp
 * @brief Alert types and data structures for the monitoring system.
 *
 * This file defines the core alert types, severities, and filtering mechanisms
 * used throughout the NetPulse monitoring application.
 */

#pragma once

#include <chrono>
#include <cstdint>
#include <optional>
#include <string>

namespace netpulse::core {

/**
 * @brief Types of alerts that can be generated by the monitoring system.
 */
enum class AlertType : int {
    HostDown = 0,      ///< Host is unreachable
    HighLatency = 1,   ///< Latency exceeds threshold
    PacketLoss = 2,    ///< Packet loss exceeds threshold
    HostRecovered = 3, ///< Previously down host is now reachable
    ScanComplete = 4   ///< Port scan has completed
};

/**
 * @brief Severity levels for alerts.
 */
enum class AlertSeverity : int {
    Info = 0,     ///< Informational alert
    Warning = 1,  ///< Warning condition
    Critical = 2  ///< Critical condition requiring immediate attention
};

/**
 * @brief Represents an alert generated by the monitoring system.
 *
 * Alerts are created when monitored hosts experience issues such as
 * becoming unreachable, having high latency, or recovering from a down state.
 */
struct Alert {
    int64_t id{0};                                      ///< Unique identifier for the alert
    int64_t hostId{0};                                  ///< ID of the host that triggered the alert
    AlertType type{AlertType::HostDown};                ///< Type of the alert
    AlertSeverity severity{AlertSeverity::Info};        ///< Severity level
    std::string title;                                  ///< Short title describing the alert
    std::string message;                                ///< Detailed alert message
    std::chrono::system_clock::time_point timestamp;    ///< When the alert was created
    bool acknowledged{false};                           ///< Whether the alert has been acknowledged

    /**
     * @brief Converts the alert type to a human-readable string.
     * @return String representation of the alert type.
     */
    [[nodiscard]] std::string typeToString() const;

    /**
     * @brief Converts the alert severity to a human-readable string.
     * @return String representation of the severity level.
     */
    [[nodiscard]] std::string severityToString() const;

    /**
     * @brief Parses a string to get the corresponding AlertType.
     * @param str The string to parse (e.g., "HostDown", "HighLatency").
     * @return The corresponding AlertType enum value.
     */
    static AlertType typeFromString(const std::string& str);

    /**
     * @brief Parses a string to get the corresponding AlertSeverity.
     * @param str The string to parse (e.g., "Info", "Warning", "Critical").
     * @return The corresponding AlertSeverity enum value.
     */
    static AlertSeverity severityFromString(const std::string& str);

    bool operator==(const Alert& other) const = default;
};

/**
 * @brief Configuration thresholds for alert generation.
 *
 * Defines the thresholds at which different types of alerts are triggered
 * based on latency, packet loss, and consecutive failures.
 */
struct AlertThresholds {
    int latencyWarningMs{100};              ///< Latency (ms) above which a warning is generated
    int latencyCriticalMs{500};             ///< Latency (ms) above which a critical alert is generated
    double packetLossWarningPercent{5.0};   ///< Packet loss (%) above which a warning is generated
    double packetLossCriticalPercent{20.0}; ///< Packet loss (%) above which a critical alert is generated
    int consecutiveFailuresForDown{3};      ///< Number of consecutive failures before marking host as down
};

/**
 * @brief Filter criteria for querying alerts.
 *
 * Used to filter alerts when retrieving them from the alert service.
 */
struct AlertFilter {
    std::optional<AlertSeverity> severity;  ///< Filter by severity level
    std::optional<AlertType> type;          ///< Filter by alert type
    std::optional<bool> acknowledged;       ///< Filter by acknowledgment status
    std::string searchText;                 ///< Text to search in title/message

    /**
     * @brief Checks if the filter has no criteria set.
     * @return True if all filter fields are empty/unset.
     */
    [[nodiscard]] bool isEmpty() const {
        return !severity.has_value() && !type.has_value() && !acknowledged.has_value() &&
               searchText.empty();
    }
};

} // namespace netpulse::core
